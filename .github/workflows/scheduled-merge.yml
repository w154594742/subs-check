name: 定时合并订阅节点

on:
  schedule:
    # 每天早上8点和晚上8点执行（UTC时间，对应北京时间16:00和次日04:00）
    - cron: '0 0,12 * * *'
  workflow_dispatch:  # 允许手动触发
  push:
    branches:
      - dev  # 添加dev分支的push触发，帮助GitHub Actions识别工作流

# 添加明确的权限
permissions:
  contents: write
  pages: write
  id-token: write

jobs:
  merge-subscriptions:
    runs-on: ubuntu-latest
    steps:
      - name: 检出代码
        uses: actions/checkout@v4
        
      - name: 创建配置目录
        run: |
          mkdir -p output
          
      - name: 准备配置文件
        run: |
          # 使用示例配置文件作为基础
          cp config/config.example.yaml config/config.yaml
          
          # 使用GitHub Secrets替换订阅链接
          # 完全清除示例配置文件中的订阅链接
          sed -i '/sub-urls:/,/^[^[:space:]-]/ {/sub-urls:/!d}' config/config.yaml
          
          # 添加来自GitHub Secrets的订阅链接
          # 将SUB_URLS按行分割并添加到配置文件
          echo "${{ secrets.SUB_URLS }}" | while IFS= read -r line || [ -n "$line" ]; do
            # 去除可能的引号和逗号
            cleaned_line=$(echo "$line" | sed 's/^[ \t"]*//;s/[ \t",]*$//')
            if [ ! -z "$cleaned_line" ]; then
              echo "  - $cleaned_line" >> config/config.yaml
            fi
          done
          
          # 设置其他配置项
          sed -i 's|check-interval:.*|check-interval: 1440|g' config/config.yaml  # 设置为24小时
          sed -i 's|print-progress:.*|print-progress: true|g' config/config.yaml  # 开启进度显示
          sed -i 's|keep-success-proxies:.*|keep-success-proxies: true|g' config/config.yaml  # 保留成功的节点
          
          # 如果有通知配置，设置通知
          if [ ! -z "${{ secrets.APPRISE_API_SERVER }}" ]; then
            sed -i "s|apprise-api-server:.*|apprise-api-server: \"${{ secrets.APPRISE_API_SERVER }}\"|g" config/config.yaml
          fi
          
          if [ ! -z "${{ secrets.RECIPIENT_URL }}" ]; then
            sed -i '/recipient-url:/,/^[a-z]/ { /recipient-url:/!d }' config/config.yaml
            echo "recipient-url:" >> config/config.yaml
            echo "  - ${{ secrets.RECIPIENT_URL }}" >> config/config.yaml
          fi
          
          # 如果有Mihomo API配置，设置Mihomo API
          if [ ! -z "${{ secrets.MIHOMO_API_URL }}" ]; then
            sed -i "s|mihomo-api-url:.*|mihomo-api-url: \"${{ secrets.MIHOMO_API_URL }}\"|g" config/config.yaml
          fi
          
          if [ ! -z "${{ secrets.MIHOMO_API_SECRET }}" ]; then
            sed -i "s|mihomo-api-secret:.*|mihomo-api-secret: \"${{ secrets.MIHOMO_API_SECRET }}\"|g" config/config.yaml
          fi
          
          # 设置保存方法
          if [ ! -z "${{ secrets.SAVE_METHOD }}" ]; then
            sed -i "s|save-method:.*|save-method: ${{ secrets.SAVE_METHOD }}|g" config/config.yaml
            
            # 根据保存方法设置相应的配置
            case "${{ secrets.SAVE_METHOD }}" in
              "gist")
                if [ ! -z "${{ secrets.GITHUB_GIST_ID }}" ]; then
                  sed -i "s|github-gist-id:.*|github-gist-id: \"${{ secrets.GITHUB_GIST_ID }}\"|g" config/config.yaml
                fi
                if [ ! -z "${{ secrets.GITHUB_TOKEN }}" ]; then
                  sed -i "s|github-token:.*|github-token: \"${{ secrets.GITHUB_TOKEN }}\"|g" config/config.yaml
                fi
                ;;
              "webdav")
                if [ ! -z "${{ secrets.WEBDAV_URL }}" ]; then
                  sed -i "s|webdav-url:.*|webdav-url: \"${{ secrets.WEBDAV_URL }}\"|g" config/config.yaml
                fi
                if [ ! -z "${{ secrets.WEBDAV_USERNAME }}" ]; then
                  sed -i "s|webdav-username:.*|webdav-username: \"${{ secrets.WEBDAV_USERNAME }}\"|g" config/config.yaml
                fi
                if [ ! -z "${{ secrets.WEBDAV_PASSWORD }}" ]; then
                  sed -i "s|webdav-password:.*|webdav-password: \"${{ secrets.WEBDAV_PASSWORD }}\"|g" config/config.yaml
                fi
                ;;
            esac
          else
            # 如果没有设置SAVE_METHOD，默认使用local 
            sed -i "s|save-method:.*|save-method: local|g" config/config.yaml
          fi
          
      - name: 运行合并订阅任务
        run: |
          # 创建一个脚本来监控Docker输出并在检测到"下次检查时间"时终止Docker
          cat > monitor.sh << 'EOF'
          #!/bin/bash
          
          # 启动Docker容器
          docker run --rm \
            -v ${{ github.workspace }}/config:/app/config \
            -v ${{ github.workspace }}/output:/app/output \
            ghcr.io/beck-8/subs-check:latest 2>&1 | while read line; do
              echo "$line"
              if [[ "$line" == *"下次检查时间"* ]]; then
                echo "检测到'下次检查时间'输出，终止Docker容器..."
                pkill -P $$ docker
                break
              fi
            done
          EOF
          
          # 添加执行权限
          chmod +x monitor.sh
          
          # 使用timeout作为备份，确保最多运行30分钟
          timeout 30m ./monitor.sh
          
          # 确保工作流继续执行
          exit 0
            
      - name: 上传结果
        uses: actions/upload-artifact@v4
        with:
          name: merged-subscriptions
          path: output/
          retention-days: 1
          
      # 检查输出目录内容
      - name: 检查输出目录内容
        run: |
          echo "输出目录内容:"
          ls -la output/
          
      # 修复中文乱码问题
      - name: 修复中文乱码问题
        run: |
          echo "检查并修复中文乱码问题..."
          
          # 安装必要的工具
          sudo apt-get update
          sudo apt-get install -y python3-pip
          pip3 install pyyaml
          
          # 创建简单的Python脚本处理YAML文件
          echo '#!/usr/bin/env python3
import yaml, sys, re, os

# 处理YAML文件
def process_yaml(file_path):
    try:
        # 读取文件内容
        with open(file_path, "r", encoding="utf-8") as f:
            content = f.read()
        
        # 替换Unicode转义序列
        content = re.sub(r"\\\\U([0-9a-fA-F]{8})", lambda m: chr(int(m.group(1), 16)), content)
        content = re.sub(r"\\\\u([0-9a-fA-F]{4})", lambda m: chr(int(m.group(1), 16)), content)
        
        # 解析YAML
        data = yaml.safe_load(content)
        
        # 重新写入文件
        with open(file_path, "w", encoding="utf-8") as f:
            yaml.dump(data, f, allow_unicode=True, default_flow_style=False, sort_keys=False)
        
        print(f"成功处理文件: {file_path}")
        return True
    except Exception as e:
        print(f"处理文件时出错: {e}")
        return False

# 主函数
if __name__ == "__main__":
    yaml_file = "output/all.yaml"
    if os.path.exists(yaml_file):
        process_yaml(yaml_file)
' > fix_yaml.py
          
          # 添加执行权限并运行
          chmod +x fix_yaml.py
          python3 fix_yaml.py
          
          # 如果Python处理失败，尝试使用sed直接替换
          if [ $? -ne 0 ]; then
            echo "Python处理失败，尝试使用sed直接替换..."
            if [ -f "output/all.yaml" ]; then
              # 使用sed替换Unicode转义序列
              sed -i 's/\\U\([0-9a-fA-F]\{8\}\)/\\u\1/g' output/all.yaml
              sed -i 's/\\u\([0-9a-fA-F]\{4\}\)/\&#x\1;/g' output/all.yaml
            fi
          fi
          
          # 处理Base64文件
          if [ -f "output/all.txt" ]; then
            echo "处理 all.txt 文件..."
            iconv -f UTF-8 -t UTF-8//IGNORE output/all.txt -o output/all.txt.tmp
            mv output/all.txt.tmp output/all.txt
          fi
          
          # 创建索引页面
          echo '<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>订阅链接</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
    h1 { color: #333; }
    .link-box { margin: 20px 0; padding: 15px; border: 1px solid #ddd; border-radius: 5px; }
    .link-box h2 { margin-top: 0; color: #444; }
    .link-box a { display: block; margin: 10px 0; word-break: break-all; }
  </style>
</head>
<body>
  <h1>订阅链接</h1>
  <div class="link-box">
    <h2>Clash/Mihomo 格式</h2>
    <a href="all.yaml">all.yaml</a>
  </div>
  <div class="link-box">
    <h2>Base64 格式</h2>
    <a href="all.txt">all.txt</a>
  </div>
</body>
</html>' > output/index.html
          
      # 配置GitHub Pages
      - name: 配置GitHub Pages
        uses: actions/configure-pages@v3
          
      # 可选：将结果推送到仓库的gh-pages分支
      - name: 部署到GitHub Pages
        if: ${{ github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.ref == 'refs/heads/dev' }}
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./output
          publish_branch: gh-pages
          force_orphan: true
          
      # 添加部署完成后的检查
      - name: 部署完成检查
        run: |
          echo "GitHub Pages部署已完成"
          echo "请访问 https://${{ github.repository_owner }}.github.io/subs-check/ 查看结果" 